// Find Closest (OpenMP)
//   - Uses OpenMP in metric loops & parallel sample-sort.
//   - Phases:
//       1: Vincenty distance (km)
//       2: Full haversine (km)
//       3: Half-haversine "a" (0..1)
//       4: Equirectangular distance (km) with adaptive pruning

#define _POSIX_C_SOURCE 200809L
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include "common.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <math.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <omp.h>

// ---------- app config ---------- 
#define EPSILON     0.05
#define ODD_EVEN_MAX_N 600000
// -----------------------------------------------------------------
//           TIME HELPERS
//  ------------------------------------------------------------- 
static inline double now_s(void) { return omp_get_wtime(); }
static inline double elapsed_ms(double t0) { return (omp_get_wtime() - t0) * 1e3; }
static inline void print_timer_res(void) {
    printf("OpenMP timer resolution: %.3f ns\n", omp_get_wtick() * 1e9);
}

// -----------------------------------------------------------------
//           MATH HELPERS
//  ------------------------------------------------------------- 

double distance_from_half(double a){
    if (a < 0) a = 0;
    if (a > 1) a = 1;
    return 2.0 * EARTH_RADIUS_KM * asin(sqrt(a));
}

static int cmp_hit_dist(const void *p1,const void *p2){
    double a=((const Hit*)p1)->dist_km;
    double b=((const Hit*)p2)->dist_km;
    return (a>b) - (a<b);
}

// -------------------------------------------------------------
//           DISTANCE FUNCTIONS
//------------------------------------------------------------- 

#pragma omp declare simd
double full_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat  = deg2rad(lat2 - lat1);
    double dlon  = deg2rad(lon_diff(lon2, lon1));
    double rlat1 = deg2rad(lat1), rlat2 = deg2rad(lat2);
    double a = pow(sin(dlat/2.0),2.0) +
               cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
    return 2.0 * EARTH_RADIUS_KM * asin(sqrt(a));
}

#pragma omp declare simd
double half_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat  = deg2rad(lat2 - lat1);
    double dlon  = deg2rad(lon_diff(lon2, lon1));
    double rlat1 = deg2rad(lat1), rlat2 = deg2rad(lat2);
    return pow(sin(dlat/2.0),2.0) +
           cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
}

static inline double equirectangular(double lat1,double lon1,double lat2,double lon2){
    double dlon = lon_diff(lon2, lon1);
    double x = deg2rad(dlon) * cos(deg2rad((lat1 + lat2)/2.0));
    double y = deg2rad(lat2 - lat1);
    return EARTH_RADIUS_KM * sqrt(x*x + y*y);
}

// ------------------------------------------------------------
//           SORT FUNCTIONS
//------------------------------------------------------------- 

// ---------- sorts over index by R[].metric ---------- 
static inline int cmp_idx_metric(const Aircraft *R, int a, int b){
    if (R[a].metric < R[b].metric) return -1;
    if (R[a].metric > R[b].metric) return  1;
    return (a<b)?-1:(a>b);
}

void odd_even_sort_idx(const Aircraft *R, int *idx, int n){
    if (n < 2) return;
    int changed;
    const int end = n - 1;
    do {
        changed = 0;
        // odd phase: pairs (1,2), (3,4), ... 
        #pragma omp parallel for schedule(static) reduction(|:changed)
        for (int i = 1; i < end; i += 2){
            if (cmp_idx_metric(R, idx[i], idx[i+1]) > 0){
                int t = idx[i];
                idx[i] = idx[i+1];
                idx[i+1] = t;
                changed = 1;
            }
        }
        // even phase: pairs (0,1), (2,3), ... 
        #pragma omp parallel for schedule(static) reduction(|:changed)
        for (int i = 0; i < end; i += 2){
            if (cmp_idx_metric(R, idx[i], idx[i+1]) > 0){
                int t = idx[i]; idx[i] = idx[i+1]; idx[i+1] = t;
                changed = 1;
            }
        }
    } while (changed);
}

static inline void merge_runs(const Aircraft *R,
                              const int *src, int *dst,
                              int left, int mid, int right)
{
    int i = left;     // cursor in [left, mid)
    int j = mid;      // cursor in [mid, right)
    int k = left;     // write cursor in dst

    while (i < mid && j < right) {
        int ai = src[i], aj = src[j];
        // stable: <= keeps left element when equal
        if (R[ai].metric < R[aj].metric ||
           (R[ai].metric == R[aj].metric && ai <= aj)) {
            dst[k++] = ai; i++;
        } else {
            dst[k++] = aj; j++;
        }
    }
    while (i < mid)   dst[k++] = src[i++];
    while (j < right) dst[k++] = src[j++];
}

static void merge_sort_idx(const Aircraft *R, int *idx, int n)
{
    if (n <= 1) return;

    int *buf = (int*)malloc((size_t)n * sizeof(int));
    if (!buf) { 
	fprintf(stderr, "OOM merge buf\n"); 
	exit(1); 
    }

    // start with src = idx, dst = buf; swap each pass
    int *src = idx;
    int *dst = buf;
    int width;

    // insertion sort for very small n
    if (n <= 32) {
        for (int i = 1; i < n; ++i) {
            int key = src[i];
	    int j = i - 1;
            while (j >= 0 &&
                   (R[src[j]].metric > R[key].metric ||
                   (R[src[j]].metric == R[key].metric && src[j] > key))) {
                src[j+1] = src[j];
                --j;
            }
            src[j+1] = key;
        }
        free(buf);
        return;
    }



    for (width = 1; width < n; width <<= 1) {

        // Only do internal OpenMP parallelism if we're *not* already
        //  inside a parallel region (e.g., not called from sample_sort_idx).
        if (!omp_in_parallel() && n>100000) {
            #pragma omp parallel for schedule(static)

	    for (int left = 0; left < n; left += (width << 1)) {
                int mid   = left + width;
                int right = left + (width << 1);
                if (mid > n)   mid   = n;
                if (right > n) right = n;
                // if already ordered, just copy
                if (mid >= right ||
                    (R[src[mid-1]].metric < R[src[mid]].metric) ||
                    (R[src[mid-1]].metric == R[src[mid]].metric && src[mid-1] <= src[mid])) {
                    for (int i = left; i < right; ++i) dst[i] = src[i];
                    continue;
                }
                merge_runs(R, src, dst, left, mid, right);
            }
        } else {

            // serial merges (small n or already inside an omp parallel region) 
            for (int left = 0; left < n; left += (width << 1)) {
                int mid   = left + width;
                int right = left + (width << 1);
                if (mid > n)   mid   = n;
                if (right > n) right = n;

                if (mid >= right ||
                    (R[src[mid-1]].metric < R[src[mid]].metric) ||
                    (R[src[mid-1]].metric == R[src[mid]].metric &&
                     src[mid-1] <= src[mid])) {
                    for (int i = left; i < right; ++i)
                        dst[i] = src[i];
                    continue;
                }
                merge_runs(R, src, dst, left, mid, right);
            }
        }

        // swap roles
        int *tmp = src; 
        src = dst; 
        dst = tmp;
    }

    // if result ended up in buf, copy back
    if (src != idx) {
        memcpy(idx, src, (size_t)n * sizeof(int));
    }
    free(buf);
}

// ---- parallel sample sort (OpenMP) ---- 
static inline int bucket_of(double key, const double *split, int B){
    int lo = 0, hi = B - 2, where = B - 1;
    while (lo <= hi){
        int mid = (lo + hi) >> 1;
        if (key <= split[mid]) { where = mid; hi = mid - 1; }
        else                   { lo = mid + 1; }
    }
    return where;
}

static void sample_sort_idx(const Aircraft *R, int *idx, int n){
    const int B = (int)fmax(4.0, floor(sqrt((double)n) * 0.5));
    const int s = 4;
    int S = B*s; if (S>n) S=n;

    int *sample=(int*)malloc(sizeof(int)*(size_t)S);
    if (!sample){ fprintf(stderr,"OOM sample\n"); exit(1); }
    double stride=(double)n/(double)S;
    for (int i=0;i<S;++i){
        int pos=(int)floor(i*stride);
        if (pos>=n) pos=n-1;
        sample[i]=idx[pos];
    }
    merge_sort_idx(R, sample, S);

    double *split=(double*)malloc(sizeof(double)*(B-1));
    if (!split){ fprintf(stderr,"OOM split\n"); exit(1); }
    for (int b=1;b<B;++b){
        int pos=(b*S)/B; if(pos>=S) pos=S-1;
        split[b-1]=R[sample[pos]].metric;
    }
    free(sample);

    int *bcounts=(int*)calloc(B,sizeof(int));
    int *boff   =(int*)malloc(sizeof(int)*(B+1));
    int *tmp    =(int*)malloc(sizeof(int)*n);
    if(!bcounts || !boff || !tmp){ fprintf(stderr,"OOM buckets\n"); exit(1); }

    int T = omp_get_max_threads();
    int *lc=(int*)calloc((size_t)T*B,sizeof(int));
    if(!lc){ fprintf(stderr,"OOM local counts\n"); exit(1); }

    #pragma omp parallel
    {
        int tid=omp_get_thread_num();
        int *lc_t=lc+tid*B;
        #pragma omp for schedule(static)
        for(int i=0;i<n;++i){
            int b=bucket_of(R[idx[i]].metric, split, B);
            lc_t[b]++;
        }
    }

    for(int b=0;b<B;++b){
        int sum=0;
        for(int t=0;t<T;++t) sum+=lc[t*B+b];
        bcounts[b]=sum;
    }
    boff[0]=0;
    for(int b=0;b<B;++b) boff[b+1]=boff[b]+bcounts[b];

    int *thread_off=(int*)malloc(sizeof(int)*(size_t)T*(size_t)B);
    if(!thread_off){ fprintf(stderr,"OOM thread_off\n"); exit(1); }
    for(int b=0;b<B;++b){
        int acc=boff[b];
        for(int t=0;t<T;++t){
            int c = lc[(size_t)t * (size_t)B + b];
            thread_off[(size_t)t * (size_t)B + b] = acc;
            acc+=c;
        }
    }

    #pragma omp parallel
    {
        int tid=omp_get_thread_num();
        int *off_t=thread_off+(size_t)tid*(size_t)B;
        int *cur=(int*)calloc((size_t)B,sizeof(int));
        if (!cur){ fprintf(stderr,"OOM cur\n"); exit(1); }
        #pragma omp for schedule(static)
        for(int i=0;i<n;++i){
            int b=bucket_of(R[idx[i]].metric, split, B);
            int pos=off_t[b]+cur[b]++;
            tmp[pos]=idx[i];
        }
        free(cur);
    }

    #pragma omp parallel for schedule(dynamic,1)
    for(int b=0;b<B;++b){
        int l=boff[b], r=boff[b+1];
        if(r-l>1) merge_sort_idx(R, tmp+l, r-l);
    }

    memcpy(idx,tmp,sizeof(int)*(size_t)n);
    free(thread_off);
    free(lc);
    free(tmp);
    free(boff);
    free(bcounts);
    free(split);
}


// --------------------------------------------------------------
//           REPORTING FUNCTIONS
//  -------------------------------------------------------------

// ---------- reporting ---------- 
static bool same_topX2(const int *A, const int *B, int X){
    for (int i=0;i<X;i++) if (A[i]!=B[i]) return false;
    return true;
}


static void run_three_sorts_fullarray_and_report(Aircraft *R, int count, int X,
                                                 int phase, double ref_lat, double ref_lon,
                                                 const char *csv_name)
{
    double t0;
    if (count <= 0 || X <= 0){ puts("\n(no results)"); return; }
    int limit = (X < count) ? X : count;

    int *base = (int*)malloc(sizeof(int)*count);
    if (!base) { fprintf(stderr,"OOM base idx\n"); exit(1); }
    for (int i=0;i<count;i++) base[i]=i;

    int *idx_odd = NULL;
    if (count < ODD_EVEN_MAX_N) {
      idx_odd = (int*)malloc(sizeof(int)*count);
      if(!idx_odd){ fprintf(stderr,"OOM idx - odd-even\n"); exit(1); }
      memcpy(idx_odd, base, sizeof(int)*count);
      t0 = now_s(); odd_even_sort_idx(R, idx_odd, count);
      double ms_odd = elapsed_ms(t0);
      printf("[Time] Even–Odd (full array): %.3f ms\n", ms_odd);
    } else {
        printf("[Skip] Even–Odd (n=%d > %d)\n", count, ODD_EVEN_MAX_N);
    }

    int *idx_merge  = (int*)malloc(sizeof(int)*count);
//    if(!idx_merge){ fprintf(stderr,"OOM idx - merge\n"); exit(1); }
//    memcpy(idx_merge, base, sizeof(int)*count);
//    t0 = now_s(); merge_sort_idx(R, idx_merge, count);
//    double ms_merge = elapsed_ms(t0);
//    printf("[Time] Merge    (full array): %.3f ms\n", ms_merge);

    int *idx_sample = (int*)malloc(sizeof(int)*count);
//    if(!idx_sample){ fprintf(stderr,"OOM idx - sample\n"); exit(1); }
//    memcpy(idx_sample, base, sizeof(int)*count);
//    t0 = now_s(); sample_sort_idx(R, idx_sample, count);
//    double ms_sample = elapsed_ms(t0);
//    printf("[Time] Sample   (full array): %.3f ms\n", ms_sample);

    if ((same_topX2(idx_merge, idx_sample, limit)) &&
        ((! idx_odd) || (same_topX2(idx_merge, idx_odd,limit)))) {

        print_top_from_idx(R, idx_merge, count, X, phase, ref_lat, ref_lon,
                           "Top-X (all three sorts agree)");
        write_csv_from_idx(csv_name, R, idx_merge, count, X, phase, ref_lat, ref_lon);
    } else {
        if (idx_odd)
            print_top_from_idx(R, idx_odd,    count, X, phase, ref_lat, ref_lon, "Top-X [Even–Odd]");
//        print_top_from_idx(R, idx_merge,  count, X, phase, ref_lat, ref_lon, "Top-X [Merge]");
//        print_top_from_idx(R, idx_sample, count, X, phase, ref_lat, ref_lon, "Top-X [Sample]");
        write_csv_from_idx(csv_name, R, idx_merge, count, X, phase, ref_lat, ref_lon);
    }

    free(idx_sample);
    free(idx_merge);
    free(idx_odd);
    free(base);
}



// --------------------------------------------------------------
//             PHASES
// ------------------------------------------------------------- 

static void phase1(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon,const char *csv_name){
    double t0=now_s();
    #pragma omp parallel for simd schedule(static)
    for(int i=0;i<count;i++){
        aircrafts[i].metric = vincenty_distance_km(ref_lat,ref_lon,
                                                   aircrafts[i].lat,aircrafts[i].lon);
    }
    double elapsed_time = elapsed_ms(t0);
    int cores = omp_get_max_threads();
    printf("[Time] Phase 1 (Vincenty) compute runtime: %.3f ms with %d threads\n",
           elapsed_time, cores);
    log_timing(LOG_FILE,"Phase1_Vincenty_OMP",count,cores,elapsed_time);
    run_three_sorts_fullarray_and_report(aircrafts, count, X, 1, ref_lat, ref_lon, csv_name);
}

static void phase2(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon, const char *csv_name){
    double t0=now_s();
    #pragma omp parallel for simd schedule(static)
    for(int i=0;i<count;i++){
        aircrafts[i].metric = full_haversine(ref_lat,ref_lon,
                                             aircrafts[i].lat,aircrafts[i].lon);
    }
    double elapsed_time = elapsed_ms(t0);
    int cores = omp_get_max_threads();
    printf("[Time] Phase 2 (Full Haversine) compute runtime: %.3f ms with %d threads\n",
           elapsed_time, cores);
    log_timing(LOG_FILE,"Phase2_FullHaversine_OMP",count,cores,elapsed_time);


    run_three_sorts_fullarray_and_report(aircrafts, count, X, 2, ref_lat, ref_lon, csv_name);
}

// Phase 3: half_haversine, metric = 'a' (0..1) 
static void phase3(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon, const char *csv_name){
    double t0=now_s();
    #pragma omp parallel for simd schedule(static)
    for(int i=0;i<count;i++){
        aircrafts[i].metric = half_haversine(ref_lat,ref_lon,
                                             aircrafts[i].lat,aircrafts[i].lon);
    }
    double elapsed_time = elapsed_ms(t0);
    int cores = omp_get_max_threads();
    printf("[Time] Phase 3 (Half Haversine 'a') compute runtime: %.3f ms with %d threads\n",
           elapsed_time, cores);
    log_timing(LOG_FILE,"Phase3_HalfHaversine_OMP",count,cores,elapsed_time);


    run_three_sorts_fullarray_and_report(aircrafts, count, X, 3, ref_lat, ref_lon, csv_name);
}

static void phase4(Aircraft *arr,int count,int X,double ref_lat,double ref_lon, const char *csv_name){
    double coslat = cos(deg2rad(ref_lat));
    if (fabs(coslat) < 1e-6) coslat = 1e-6;
    const int use_lon = fabs(ref_lat) < 80.0;

    if (X <= 0 || count <= 0) { 
	puts("No candidates after streaming."); 
	return; 
    }

    double t0 = now_s();

    int T = omp_get_max_threads();

    // per-thread heaps and sizes 
    Hit *heaps = (Hit*)malloc((size_t)T * (size_t)X * sizeof(Hit));
    int *sizes = (int*)calloc((size_t)T, sizeof(int));
    if(!heaps || !sizes) { 
	fprintf(stderr,"OOM phase4 heaps\n"); 
	free(heaps);
	free(sizes);
	exit(1); 
    }

    int bbox_survivors = 0;

    #pragma omp parallel
    {
        int tid = omp_get_thread_num();
        Hit *h = heaps + (size_t)tid * (size_t)X; // this thread’s heap 
        int   k_local = 0;                        // current heap size 

        double cutoff_km = INFINITY;
        double lat_thresh_deg = INFINITY;
        double lon_thresh_deg = use_lon ? INFINITY : 360.0;

        #pragma omp for schedule(static) reduction(+:bbox_survivors)
        for (int i=0; i<count; ++i){
            // bounding box prune using this thread's current worst 
            if (k_local == X){
                double dlat = fabs(arr[i].lat - ref_lat);
                if (dlat > lat_thresh_deg) continue;
                if (use_lon){
                    double dlon = fabs(lon_diff(arr[i].lon, ref_lon));
                    if (dlon > lon_thresh_deg) continue;
                }
            }

            // cheap distance 
            double d_eq = equirectangular(ref_lat, ref_lon, arr[i].lat, arr[i].lon);
            ++bbox_survivors;
       
            // Check if this ICAO already in the heap
            int dup_idx = -1;
            for (int hh = 0; hh < k_local; ++hh) {
                if (strcmp(arr[h[hh].idx].icao24, arr[i].icao24) == 0) {
                    dup_idx = hh;
                    break;
                }
            } 

            if (dup_idx >= 0) {
                // We already track this aircraft: keep the closer encounter 
                if (d_eq < h[dup_idx].dist_km) {
                    h[dup_idx].dist_km = d_eq;
                    // Re-heapify around that position 
                    heap_sift_down(h, k_local, dup_idx);

                    if (k_local == X) {
                        cutoff_km      = heap_top(h).dist_km * (1.0 + EPSILON);
                        lat_thresh_deg = cutoff_km / 111.0;
                        lon_thresh_deg = use_lon ? cutoff_km / (111.0 * coslat) : 360.0;
                    }
                }
                continue;
            }

            if (k_local < X){
                heap_push(h, &k_local, (Hit){ d_eq, i });
                if (k_local == X){
                    cutoff_km      = heap_top(h).dist_km * (1.0 + EPSILON);
                    lat_thresh_deg = cutoff_km / 111.0;
                    lon_thresh_deg = use_lon ? cutoff_km / (111.0 * coslat) : 360.0;
                }
            } else {
                double worst = heap_top(h).dist_km;
                if (d_eq <= worst * (1.0 + EPSILON)){
                    heap_replace_top(h, k_local, (Hit){ d_eq, i });
                    cutoff_km      = heap_top(h).dist_km * (1.0 + EPSILON);
                    lat_thresh_deg = cutoff_km / 111.0;
                    lon_thresh_deg = use_lon ? cutoff_km / (111.0 * coslat) : 360.0;
                }
            }
        }

        sizes[tid] = k_local; 
    } // end parallel 

    // merge all thread-local heaps into one candidate list 
    int total = 0;
    for (int t=0; t<T; ++t) total += sizes[t];

    if (total == 0){
        puts("No candidates after streaming.");
        free(sizes); free(heaps);
        return;
    }

    Hit *cand = (Hit*)malloc((size_t)total * sizeof(Hit));
    if(!cand){ 
	fprintf(stderr,"OOM phase4 cand\n"); 
	free(sizes);
	free(heaps);
	return; 
    }
    int pos = 0;
    for (int t=0; t<T; ++t){
        int k_local = sizes[t];
        if (k_local > 0){
            memcpy(cand + pos, 
	           heaps + (size_t)t * (size_t)X, 
		   (size_t)k_local * sizeof(Hit));
            pos += k_local;
        }
    }
    free(sizes);
    free(heaps);

    // Keep best X by equirectangular distance (sort is fine; total ≤ T*X) 
    qsort(cand, (size_t)total, sizeof(Hit), cmp_hit_dist);
    //    int k = (X < total) ? X : total;

    // build index list for printing/CSV and store final metric 
    int *idx_refined = (int*)malloc((size_t)X * sizeof(int));
    if(!idx_refined){ 
	fprintf(stderr,"OOM phase4 idx_refined\n"); 
	free(cand);
	return;
    }

    int k_unique = 0;
    for (int c=0; c<total && k_unique < X; ++c) {
        int idx = cand[c].idx;
        const char *icao = arr[idx].icao24;
        int dup = 0;
        for (int j = 0; j < k_unique; ++j) {
            if (strcmp(arr[idx_refined[j]].icao24, icao) == 0) {
	        dup = 1;
		break;
            }
        }
        if (dup) continue;



	idx_refined[k_unique]  = idx;
        arr[idx].metric = cand[c].dist_km;  // equirectangular km 
	++k_unique;
    }

    free(cand);

    double elapsed_time = elapsed_ms(t0);
    int cores = omp_get_max_threads();
    printf("Bounding-box survivors: %d of %d\n", bbox_survivors, count);
    printf("Post-equirectangular survivors (unique aircraft, merged): %d\n", k_unique);
    printf("Phase 4 runtime: %.3f ms with %d threads\n", elapsed_time, cores);
    log_timing(LOG_FILE,"Phase4_PruneRefine_Equirect_OMP",count,cores,elapsed_time);
    print_top_from_idx(arr, idx_refined, k_unique, X, 4, ref_lat, ref_lon,
		                           "Phase 4 (Adaptive Pruning, Equirectangular, OMP)");
    write_csv_from_idx(csv_name, arr, idx_refined, k_unique, X, 4, ref_lat, ref_lon);

    free(idx_refined);
}
// ---------- main ----------
// ---------- main ----------
int main(int argc,char *argv[]){
    Args args = parse_args(argc, argv);

    if (args.phase < 1 || args.phase > 4){
        fprintf(stderr,
            "Usage: %s --phase {1|2|3|4} [lat lon X] [--data-file <path>] [--use-rows rows_per_thread]\n", argv[0]);
        fprintf(stderr,
            "Example: %s --phase=3 30.4733 -87.1866 25 "
            "--data-file input/myfile.csv --use-rows 3000000\n", argv[0]);
        return 1;
    }

    /* Short phase tag for filenames */
    const char *phase_tag =
        (args.phase==1) ? "phase1" :
        (args.phase==2) ? "phase2" :
        (args.phase==3) ? "phase3" : "phase4";

    if (ensure_dir("output") != 0){
        perror("ensure_dir(\"output\")");
    }

    printf("Phase: %d\n", args.phase);
    printf("Ref: (%.4f, %.4f), TopX=%d\n", args.ref_lat, args.ref_lon, args.topX);
    printf("Data file: %s\n", args.data_file);
    if (args.use_rows > 0) {
        printf("Weak-scaling base: %d rows per thread (from --use-rows)\n",
               args.use_rows);
    } else {
        printf("Weak-scaling base: (will choose automatically if needed)\n");
    }

    /* -------- load data ONCE (may be many CSV / .gz files) -------- */
    int capacity = 0;
    int global_count = 0;
    Aircraft *aircrafts = NULL;
    int rc = 0;

    printf("Data file: %s\n", args.data_file);

    if (strpbrk(args.data_file, "*?[]") != NULL) {
        rc = load_csv_pattern(args.data_file, &aircrafts, &global_count, &capacity);
    } else {
        rc = load_csv(args.data_file, &aircrafts, &global_count, &capacity);
    }

    if (rc != 0) {
        fprintf(stderr, "Failed to load from '%s'\n", args.data_file);
        if (aircrafts) free(aircrafts);
        return 1;
    }

    printf("Loaded %d records total\n", global_count);
    if (global_count == 0) {
        free(aircrafts);
        return 0;
    }

    // show timer resolution once
    print_timer_res();

    int max_threads = omp_get_max_threads();
    printf("Max available OpenMP threads (this run): %d\n", max_threads);

    /* -------- configure thread sweep (weak scaling) --------
       Example: 1 -> 3M rows, 2 -> 6M rows, 4 -> 12M rows, ...
       You can tweak this list as desired.
    */
    int thread_list[] = {1, 2, 4, 8, 12, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 127};
    int n_thread_list = (int)(sizeof(thread_list) / sizeof(thread_list[0]));

    /* base rows-per-thread: from --use-rows if given, otherwise fall back */
    int base_rows_per_thread = args.use_rows;
    if (base_rows_per_thread <= 0) {
        /* Fallback heuristic: distribute total rows roughly evenly
           over max_threads, so the largest T uses almost all rows. */
        base_rows_per_thread = (global_count + max_threads - 1) / max_threads;
        printf("Auto base_rows_per_thread = %d\n", base_rows_per_thread);
    }

    for (int ti = 0; ti < n_thread_list; ++ti) {
        int T = thread_list[ti];
        if (T < 1 || T > max_threads) {
            continue;   // skip if this many threads isn’t available
        }

        omp_set_num_threads(T);

        /* rows_for_T = base_rows_per_thread * T, clamped to total rows */
        long long want_rows = (long long)base_rows_per_thread * (long long)T;
        int rows_for_T = (want_rows > global_count) ? global_count : (int)want_rows;

        if (rows_for_T <= 0) {
            continue;
        }

        char csv_name[256];
        /* Example: output/phase1-output-omp-1t-3000000rows.csv */
        snprintf(csv_name, sizeof(csv_name),
                 "output/%s-output-omp-%dt-%drows.csv",
                 phase_tag, T, rows_for_T);

        printf("\n========================================\n");
        printf("Running phase %d with %d OpenMP threads\n", args.phase, T);
        printf("Using first %d of %d rows (base %d rows/thread)\n",
               rows_for_T, global_count, base_rows_per_thread);
        printf("Output: %s\n", csv_name);
        printf("========================================\n");

        if      (args.phase==1)
            phase1(aircrafts, rows_for_T, args.topX,
                   args.ref_lat, args.ref_lon, csv_name);
        else if (args.phase==2)
            phase2(aircrafts, rows_for_T, args.topX,
                   args.ref_lat, args.ref_lon, csv_name);
        else if (args.phase==3)
            phase3(aircrafts, rows_for_T, args.topX,
                   args.ref_lat, args.ref_lon, csv_name);
        else
            phase4(aircrafts, rows_for_T, args.topX,
                   args.ref_lat, args.ref_lon, csv_name);
    }

    free(aircrafts);
    return 0;
}

