/***********************************************************************
 * Find Closest (OpenMP)
 *   - Uses OpenMP in metric loops & parallel sample-sort.
 *   - Sorts & haversine math live here.
 ***********************************************************************/

#define _POSIX_C_SOURCE 200809L
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include "common.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <math.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <omp.h>

/* ---------- app config ---------- */
#define EPSILON     0.05
#define LOG_FILE  "output/timings.csv"
/* ---- Vincenty inverse distance on WGS-84 (returns kilometers) ---- */
#define WGS84_A 6378137.0                 /* meters */
#define WGS84_F (1.0/298.257223563)
#define WGS84_B (WGS84_A*(1.0 - WGS84_F))

/* -----------------------------------------------------------------
 *           TIME HELPERS
 *  ------------------------------------------------------------- */
static inline double now_s(void) { return omp_get_wtime(); }

static inline double elapsed_ms(double t0) { return (omp_get_wtime() - t0) * 1e3; }

static inline void print_timer_res(void) {
    printf("OpenMP timer resolution: %.3f ns\n", omp_get_wtick() * 1e9);
}

/* -----------------------------------------------------------------
 *           MATH HELPERS
 *  ------------------------------------------------------------- */
//#pragma omp declare simd notinbranch
static inline double deg2rad(double deg){ return deg * M_PI / 180.0; }

//#pragma omp declare simd notinbranch
static inline double lon_diff(double lon1, double lon2){
    double dlon = lon1 - lon2;
    while(dlon > 180.0)  dlon -= 360.0;
    while(dlon < -180.0) dlon += 360.0;
    return dlon;
}

double distance_from_half(double a){
    if (a < 0) a = 0;
    if (a > 1) a = 1;
    return 2.0 * EARTH_RADIUS_KM * asin(sqrt(a));
}

static int cmp_hit_dist(const void *p1,const void *p2){
    double a=((const Hit*)p1)->dist_km;
    double b=((const Hit*)p2)->dist_km;
    return (a>b) - (a<b);
}

/* -----------------------------------------------------------------
 *           DISTANCE FUNCTIONS
 *  ------------------------------------------------------------- */

//#pragma omp declare simd notinbranch uniform(lat1,lon1)
static inline double equirectangular(double lat1,double lon1,double lat2,double lon2){
    double dlon = lon_diff(lon2, lon1);
    double x = deg2rad(dlon) * cos(deg2rad((lat1 + lat2)/2.0));
    double y = deg2rad(lat2 - lat1);
    return EARTH_RADIUS_KM * sqrt(x*x + y*y);
}

//#pragma omp declare simd notinbranch uniform(lat1,lon1)
double half_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat  = deg2rad(lat2 - lat1);
    double dlon  = deg2rad(lon_diff(lon2, lon1));
    double rlat1 = deg2rad(lat1), rlat2 = deg2rad(lat2);
    return pow(sin(dlat/2.0),2.0) +
           cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
}

//#pragma omp declare simd notinbranch uniform(lat1,lon1)
double full_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat  = deg2rad(lat2 - lat1);
    double dlon  = deg2rad(lon_diff(lon2, lon1));
    double rlat1 = deg2rad(lat1), rlat2 = deg2rad(lat2);
    double a = pow(sin(dlat/2.0),2.0) +
               cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
    return 2.0 * EARTH_RADIUS_KM * asin(sqrt(a));
}

/* Robust Vincenty inverse; falls back to haversine if it fails to converge. */
static double vincenty_distance_km(double lat1, double lon1,
                                   double lat2, double lon2)
{
    /* identical points */
    if (lat1 == lat2 && lon1 == lon2) return 0.0;

    double phi1 = deg2rad(lat1);
    double phi2 = deg2rad(lat2);
    double U1 = atan((1.0 - WGS84_F) * tan(phi1));
    double U2 = atan((1.0 - WGS84_F) * tan(phi2));
    double sinU1 = sin(U1), cosU1 = cos(U1);
    double sinU2 = sin(U2), cosU2 = cos(U2);
    /* use normalized longitude difference */
    double L = deg2rad(lon_diff(lon2, lon1));
    double lambda = L, lambda_prev;
    double sinSigma, cosSigma, sigma;
    double sinAlpha, cos2Alpha, cos2SigmaM, C;
    /* iterate lambda */
    for (int iter = 0; iter < 100; ++iter) {
        double sinLambda = sin(lambda);
        double cosLambda = cos(lambda);

        double t1 = cosU2 * sinLambda;
        double t2 = cosU1 * sinU2 - sinU1 * cosU2 * cosLambda;
        sinSigma  = sqrt(t1*t1 + t2*t2);
        if (sinSigma == 0.0) return 0.0; /* coincident */

        cosSigma  = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
        sigma     = atan2(sinSigma, cosSigma);

        sinAlpha  = (cosU1 * cosU2 * sinLambda) / sinSigma;
        cos2Alpha = 1.0 - sinAlpha * sinAlpha;

        if (cos2Alpha != 0.0)
            cos2SigmaM = cosSigma - 2.0 * sinU1 * sinU2 / cos2Alpha;
        else
            cos2SigmaM = 0.0; /* equatorial line */

        C = (WGS84_F / 16.0) * cos2Alpha * (4.0 + WGS84_F * (4.0 - 3.0 * cos2Alpha));

        lambda_prev = lambda;
        lambda = L + (1.0 - C) * WGS84_F * sinAlpha *
                 (sigma + C * sinSigma *
                  (cos2SigmaM + C * cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)));

        if (fabs(lambda - lambda_prev) < 1e-12) break;

        if (iter == 99) {
            printf("-----------NO iteration----------------");
            /* No convergence: fall back to spherical distance */
            return full_haversine(lat1, lon1, lat2, lon2);
        }
    }

    double uSq = cos2Alpha * ((WGS84_A*WGS84_A - WGS84_B*WGS84_B) / (WGS84_B*WGS84_B));
    double A = 1.0 + uSq/16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0*uSq)));
    double B =       uSq/1024.0  * ( 256.0 + uSq * (-128.0 + uSq * ( 74.0 -  47.0*uSq)));
    double deltaSigma = B * sinSigma *
        (cos2SigmaM + (B/4.0) * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM) -
         (B/6.0) * cos2SigmaM * (-3.0 + 4.0 * sinSigma * sinSigma)
                            * (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));

    double s_m = WGS84_B * A * (sigma - deltaSigma); /* meters */
    return s_m * 1e-3; /* kilometers */
}

/* Convenience wrapper if you prefer calling with an Aircraft */
static inline double vincenty_ref_to_aircraft_km(double ref_lat, double ref_lon,
                                                 const Aircraft *ac)
{
    return vincenty_distance_km(ref_lat, ref_lon, ac->lat, ac->lon);
}

/* -----------------------------------------------------------------
 *           SORT FUNCTIONS
 *  ------------------------------------------------------------- */

/* ---------- sorts over index by R[].metric ---------- */
static inline int cmp_idx_metric(const Aircraft *R, int a, int b){
    if (R[a].metric < R[b].metric) return -1;
    if (R[a].metric > R[b].metric) return  1;
    return (a<b)?-1:(a>b);
}

void odd_even_sort_idx(const Aircraft *R, int *idx, int n){
    if (n < 2) return;
    int changed;
    const int end = n - 1;
    do {
        changed = 0;
        /* odd phase: pairs (1,2), (3,4), ... */
        #pragma omp parallel for schedule(static) reduction(|:changed)
        for (int i = 1; i < end; i += 2){
            if (cmp_idx_metric(R, idx[i], idx[i+1]) > 0){
                int t = idx[i];
                idx[i] = idx[i+1];
                idx[i+1] = t;
                changed = 1;
            }
        }
        /* even phase: pairs (0,1), (2,3), ... */
        #pragma omp parallel for schedule(static) reduction(|:changed)
        for (int i = 0; i < end; i += 2){
            if (cmp_idx_metric(R, idx[i], idx[i+1]) > 0){
                int t = idx[i]; idx[i] = idx[i+1]; idx[i+1] = t;
                changed = 1;
            }
        }
    } while (changed);
}

static inline void merge_runs(const Aircraft *R,
                              const int *src, int *dst,
                              int left, int mid, int right)
{
    int i = left;     // cursor in [left, mid)
    int j = mid;      // cursor in [mid, right)
    int k = left;     // write cursor in dst

    while (i < mid && j < right) {
        int ai = src[i], aj = src[j];
        // stable: <= keeps left element when equal
        if (R[ai].metric < R[aj].metric ||
           (R[ai].metric == R[aj].metric && ai <= aj)) {
            dst[k++] = ai; i++;
        } else {
            dst[k++] = aj; j++;
        }
    }
    while (i < mid)   dst[k++] = src[i++];
    while (j < right) dst[k++] = src[j++];
}

static void merge_sort_idx(const Aircraft *R, int *idx, int n)
{
    if (n <= 1) return;

    int *buf = (int*)malloc((size_t)n * sizeof(int));
    if (!buf) { fprintf(stderr, "OOM merge buf\n"); exit(1); }

    // start with src = idx, dst = buf; swap each pass
    int *src = idx;
    int *dst = buf;
    int width;

    // insertion sort for very small n (cheap & avoids tiny merges)
    if (n <= 32) {
        for (int i = 1; i < n; ++i) {
            int key = src[i], j = i - 1;
            while (j >= 0 &&
                   (R[src[j]].metric > R[key].metric ||
                   (R[src[j]].metric == R[key].metric && src[j] > key))) {
                src[j+1] = src[j];
                --j;
            }
            src[j+1] = key;
        }
        free(buf);
        return;
    }

    for (width = 1; width < n; width <<= 1) {
        for (int left = 0; left < n; left += (width << 1)) {
            int mid   = left + width;
            int right = left + (width << 1);
            if (mid > n)   mid   = n;
            if (right > n) right = n;
            // if already ordered, just copy
            if (mid >= right ||
                (R[src[mid-1]].metric < R[src[mid]].metric) ||
                (R[src[mid-1]].metric == R[src[mid]].metric && src[mid-1] <= src[mid])) {
                // contiguous copy from src->dst
                for (int i = left; i < right; ++i) dst[i] = src[i];
                continue;
            }
            merge_runs(R, src, dst, left, mid, right);
        }
        // swap roles
        int *tmp = src; src = dst; dst = tmp;
    }

    // if result ended up in buf, copy back
    if (src != idx) {
        memcpy(idx, src, (size_t)n * sizeof(int));
    }
    free(buf);
}

/* ---- parallel sample sort (OpenMP) ---- */
static inline int bucket_of(double key, const double *split, int B){
    int lo = 0, hi = B - 2, where = B - 1;
    while (lo <= hi){
        int mid = (lo + hi) >> 1;
        if (key <= split[mid]) { where = mid; hi = mid - 1; }
        else                   { lo = mid + 1; }
    }
    return where;
}

static void sample_sort_idx(const Aircraft *R, int *idx, int n){
    const int B = (int)fmax(4.0, floor(sqrt((double)n) * 0.5));
    const int s = 4;
    int S = B*s; if (S>n) S=n;

    int *sample=(int*)malloc(sizeof(int)*(size_t)S);
    if (!sample){ fprintf(stderr,"OOM sample\n"); exit(1); }
    double stride=(double)n/(double)S;
    for (int i=0;i<S;++i){
        int pos=(int)floor(i*stride);
        if (pos>=n) pos=n-1;
        sample[i]=idx[pos];
    }
    merge_sort_idx(R, sample, S);

    double *split=(double*)malloc(sizeof(double)*(B-1));
    if (!split){ fprintf(stderr,"OOM split\n"); exit(1); }
    for (int b=1;b<B;++b){
        int pos=(b*S)/B; if(pos>=S) pos=S-1;
        split[b-1]=R[sample[pos]].metric;
    }
    free(sample);

    int *bcounts=(int*)calloc(B,sizeof(int));
    int *boff=(int*)malloc(sizeof(int)*(B+1));
    int *tmp=(int*)malloc(sizeof(int)*n);
    if(!bcounts || !boff || !tmp){ fprintf(stderr,"OOM buckets\n"); exit(1); }

    int T=1;
    T = omp_get_max_threads();
    int *lc=(int*)calloc((size_t)T*B,sizeof(int));
    if(!lc){ fprintf(stderr,"OOM local counts\n"); exit(1); }

    #pragma omp parallel
    {
        int tid=omp_get_thread_num();
        int *lc_t=lc+tid*B;
        #pragma omp for schedule(static)
        for(int i=0;i<n;++i){
            int b=bucket_of(R[idx[i]].metric, split, B);
            lc_t[b]++;
        }
    }

    for(int b=0;b<B;++b){
        int sum=0;
        for(int t=0;t<T;++t) sum+=lc[t*B+b];
        bcounts[b]=sum;
    }
    boff[0]=0;
    for(int b=0;b<B;++b) boff[b+1]=boff[b]+bcounts[b];

    int *thread_off=(int*)malloc(sizeof(int)*(size_t)T*(size_t)B);
    if(!thread_off){ fprintf(stderr,"OOM thread_off\n"); exit(1); }
    for(int b=0;b<B;++b){
        int acc=boff[b];
        for(int t=0;t<T;++t){
            int c = lc[(size_t)t * (size_t)B + b];
            thread_off[(size_t)t * (size_t)B + b] = acc;
            acc+=c;
        }
    }

    #pragma omp parallel
    {
        int tid=omp_get_thread_num();
        int *off_t=thread_off+(size_t)tid*(size_t)B;
        int *cur=(int*)calloc((size_t)B,sizeof(int));
        if (!cur){ fprintf(stderr,"OOM cur\n"); exit(1); }
        #pragma omp for schedule(static)
        for(int i=0;i<n;++i){
            int b=bucket_of(R[idx[i]].metric, split, B);
            int pos=off_t[b]+cur[b]++;
            tmp[pos]=idx[i];
        }
        free(cur);
    }

    #pragma omp parallel for schedule(dynamic,1)
    for(int b=0;b<B;++b){
        int l=boff[b], r=boff[b+1];
        if(r-l>1) merge_sort_idx(R, tmp+l, r-l);
    }

    memcpy(idx,tmp,sizeof(int)*(size_t)n);
    free(thread_off);
    free(lc);
    free(tmp);
    free(boff);
    free(bcounts);
    free(split);
}


/* -----------------------------------------------------------------
 *           REPORTING FUNCTIONS
 *  ------------------------------------------------------------- */

/* ---------- reporting ---------- */
static bool same_topX2(const int *A, const int *B, int X){
    for (int i=0;i<X;i++) if (A[i]!=B[i]) return false;
    return true;
}

static void run_three_sorts_fullarray_and_report(Aircraft *R, int count, int X,
                                                 int phase, double ref_lat, double ref_lon)
{
    double t0;
    if (count <= 0 || X <= 0){ puts("\n(no results)"); return; }
    int limit = (X < count) ? X : count;

    int *base = (int*)malloc(sizeof(int)*count);
    for (int i=0;i<count;i++) base[i]=i;

    int *idx_odd = NULL;
    if (count < 300000) {
      idx_odd = (int*)malloc(sizeof(int)*count);
      if(!base||!idx_odd){ fprintf(stderr,"OOM idx - odd-even\n"); exit(1); }
      memcpy(idx_odd, base, sizeof(int)*count);
      t0 = now_s(); odd_even_sort_idx(R, idx_odd, count);
      double ms_odd = elapsed_ms(t0);
      printf("[Time] Even–Odd (full array): %.3f ms\n", ms_odd);
    }

    int *idx_merge  = (int*)malloc(sizeof(int)*count);
    if(!base||!idx_merge){ fprintf(stderr,"OOM idx - merge\n"); exit(1); }
    memcpy(idx_merge, base, sizeof(int)*count);
    t0 = now_s(); merge_sort_idx(R, idx_merge, count);
    double ms_merge = elapsed_ms(t0);
    printf("[Time] Merge    (full array): %.3f ms\n", ms_merge);

    int *idx_sample = (int*)malloc(sizeof(int)*count);
    if(!base||!idx_sample){ fprintf(stderr,"OOM idx - sample\n"); exit(1); }
    memcpy(idx_sample, base, sizeof(int)*count);
    t0 = now_s(); sample_sort_idx(R, idx_sample, count);
    double ms_sample = elapsed_ms(t0);
    printf("[Time] Sample   (full array): %.3f ms\n", ms_sample);

    const char *auto_name =
        (phase==1) ? "output/phase1-output.csv" :
        (phase==2) ? "output/phase2-output.csv" : "output/phaseX-output.csv";

    if ((same_topX2(idx_merge, idx_sample, limit)) && 
	((! idx_odd) || (same_topX2(idx_merge, idx_odd,limit)))) {
	
        print_top_from_idx(R, idx_merge, count, X, phase, ref_lat, ref_lon,
                           "Top-X (all three sorts agree)");
        write_csv_from_idx(auto_name, R, idx_merge, limit, phase, ref_lat, ref_lon);
    } else {
	if (idx_odd)
            print_top_from_idx(R, idx_odd,    count, X, phase, ref_lat, ref_lon, "Top-X [Even–Odd]");
        print_top_from_idx(R, idx_merge,  count, X, phase, ref_lat, ref_lon, "Top-X [Merge]");
        print_top_from_idx(R, idx_sample, count, X, phase, ref_lat, ref_lon, "Top-X [Sample]");
        write_csv_from_idx(auto_name, R, idx_merge, limit, phase, ref_lat, ref_lon);
    }

    free(idx_sample);
    free(idx_merge);
    free(idx_odd);
    free(base);
}

/* -----------------------------------------------------------------
 *             PHASES  
 *  ------------------------------------------------------------- */

static void phase1(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon){
    double t0=now_s();
    #pragma omp parallel for simd schedule(static)
    for(int i=0;i<count;i++){
        aircrafts[i].metric = vincenty_distance_km(ref_lat,ref_lon,
                                             aircrafts[i].lat,aircrafts[i].lon);
    }
    double elapsed_time = elapsed_ms(t0);
    printf("[Time] Vincenty compute runtime: %.3f ms\n",elapsed_time);
    log_timing(LOG_FILE,"Phase1_Vincenty_Distance",count,1,elapsed_time);
    run_three_sorts_fullarray_and_report(aircrafts, count, X, 1, ref_lat, ref_lon);
}

static void phase2(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon){
    double t0=now_s();
    #pragma omp parallel for simd schedule(static)
    for(int i=0;i<count;i++){
//        aircrafts[i].metric = half_haversine(ref_lat,ref_lon,aircrafts[i].lat,aircrafts[i].lon);
        aircrafts[i].metric = full_haversine(ref_lat,ref_lon,aircrafts[i].lat,aircrafts[i].lon);
    }
    double elapsed_time = elapsed_ms(t0);
    printf("[Time] Full Haversine compute runtime: %.3f ms\n",elapsed_time);
    log_timing(LOG_FILE,"Phase2_FULL_Haversine_Distance",count,1,elapsed_time);
    run_three_sorts_fullarray_and_report(aircrafts, count, X, 2, ref_lat, ref_lon);
}

static void phase3(Aircraft *arr,int count,int X,double ref_lat,double ref_lon){
    double coslat = cos(deg2rad(ref_lat));
    if (fabs(coslat) < 1e-6) coslat = 1e-6;
    const int use_lon = fabs(ref_lat) < 80.0;

    if (X <= 0 || count <= 0){ puts("No candidates after streaming."); return; }

    double t0 = now_s();

    /* how many threads will participate */
    int T = 1;
    T = omp_get_max_threads();

    /* per-thread heaps and sizes */
    Hit *heaps = (Hit*)malloc((size_t)T * (size_t)X * sizeof(Hit));
    int *sizes = (int*)calloc((size_t)T, sizeof(int));
    if(!heaps || !sizes){ fprintf(stderr,"OOM phase3 heaps\n"); exit(1); }

    int bbox_survivors = 0;

#pragma omp parallel
    {
        int tid = 0;
        tid = omp_get_thread_num();
        Hit *h = heaps + (size_t)tid * (size_t)X; /* this thread’s heap */
        int   k = 0;                               /* current heap size */

        double cutoff_km = INFINITY;
        double lat_thresh_deg = INFINITY;
        double lon_thresh_deg = use_lon ? INFINITY : 360.0;

#pragma omp for schedule(static) reduction(+:bbox_survivors)
        for (int i=0; i<count; ++i){
            /* bounding box prune using this thread's current worst */
            if (k == X){
                double dlat = fabs(arr[i].lat - ref_lat);
                if (dlat > lat_thresh_deg) continue;
                if (use_lon){
                    double dlon = fabs(lon_diff(arr[i].lon, ref_lon));
                    if (dlon > lon_thresh_deg) continue;
                }
            }

            /* cheap distance */
            double d_eq = equirectangular(ref_lat, ref_lon, arr[i].lat, arr[i].lon);
            ++bbox_survivors;

            if (k < X){
                heap_push(h, &k, (Hit){ d_eq, i });
                if (k == X){
                    cutoff_km      = heap_top(h).dist_km * (1.0 + EPSILON);
                    lat_thresh_deg = cutoff_km / 111.0;
                    lon_thresh_deg = use_lon ? cutoff_km / (111.0 * coslat) : 360.0;
                }
            } else {
                double worst = heap_top(h).dist_km;
                if (d_eq <= worst * (1.0 + EPSILON)){
                    heap_replace_top(h, k, (Hit){ d_eq, i });
                    cutoff_km      = heap_top(h).dist_km * (1.0 + EPSILON);
                    lat_thresh_deg = cutoff_km / 111.0;
                    lon_thresh_deg = use_lon ? cutoff_km / (111.0 * coslat) : 360.0;
                }
            }
        }

        sizes[tid] = k; /* publish local heap size */
    } /* end parallel */

    /* merge all thread-local heaps into one candidate list */
    int total = 0;
    for (int t=0; t<T; ++t) total += sizes[t];

    if (total == 0){
        puts("No candidates after streaming.");
        free(sizes); free(heaps);
        return;
    }

    Hit *cand = (Hit*)malloc((size_t)total * sizeof(Hit));
    if(!cand){ fprintf(stderr,"OOM phase3 cand\n"); exit(1); }
    int pos = 0;
    for (int t=0; t<T; ++t){
        int k = sizes[t];
        if (k > 0){
            memcpy(cand + pos, heaps + (size_t)t * (size_t)X, (size_t)k * sizeof(Hit));
            pos += k;
        }
    }
    free(sizes); free(heaps);

    /* Keep best X by equirectangular distance (sort is fine; total ≤ T*X) */
    qsort(cand, (size_t)total, sizeof(Hit), cmp_hit_dist);
    int k = (X < total) ? X : total;

    /* compute TRUE distances for survivors in parallel */
    Hit *refined = (Hit*)malloc((size_t)k * sizeof(Hit));
    if(!refined){ fprintf(stderr,"OOM phase3 refined\n"); exit(1); }
//#pragma omp parallel for schedule(static) if(k>10000)
    for (int j=0; j<k; ++j){
        int idx = cand[j].idx;
        refined[j].idx     = idx;
        refined[j].dist_km = full_haversine(ref_lat, ref_lon, arr[idx].lat, arr[idx].lon);
    }
    free(cand);
    /* final small sort by true distance */
    qsort(refined, (size_t)k, sizeof(Hit), cmp_hit_dist);
    /* build index list for printing/CSV */
    int *idx_refined = (int*)malloc((size_t)k * sizeof(int));
    if(!idx_refined){ fprintf(stderr,"OOM phase3 idx_refined\n"); exit(1); }
    for (int i=0; i<k; ++i) idx_refined[i] = refined[i].idx;

    print_top_from_idx(arr, idx_refined, k, k, 3, ref_lat, ref_lon,
                       "Phase 3 (Adaptive Pruning, OMP)");
    write_csv_from_idx("output/phase3-output.csv", arr, idx_refined, k, 3, ref_lat, ref_lon);

    free(idx_refined);
    free(refined);

    double elapsed_time = elapsed_ms(t0);
    printf("Bounding-box survivors: %d of %d\n", bbox_survivors, count);
    printf("Post-equirectangular survivors (merged): %d\n", k);
    printf("Phase 3 runtime: %.3f ms\n", elapsed_time);
    log_timing(LOG_FILE,"Phase3_PruneRefine_OMP",count,1,elapsed_time);
}

/* ---------- main ---------- */
int main(int argc,char *argv[]){
    Args args = parse_args(argc, argv);

    if (args.phase < 1 || args.phase > 3){
        fprintf(stderr,
            "Usage: %s --phase {1|2|3} [lat lon X] [--data-file <path>]\n", argv[0]);
        fprintf(stderr,
            "Example: %s --phase=3 30.4733 -87.1866 25 --data-file input/myfile.csv\n", argv[0]);
        return 1;
    }

    const char *auto_name =
        (args.phase==1) ? "output/phase1-output.csv" :
        (args.phase==2) ? "output/phase2-output.csv" :
                          "output/phase3-output.csv";

    if (ensure_dir("output") != 0){
        perror("ensure_dir(\"output\")");
    }
    printf("Phase: %d\n", args.phase);
    printf("Output: %s\n", auto_name);
    printf("Ref: (%.4f, %.4f), TopX=%d\n", args.ref_lat, args.ref_lon, args.topX);
    printf("Data file: %s\n", args.data_file);

    int capacity = INIT_CAPACITY;
    int count = 0;
    Aircraft *aircrafts = (Aircraft*)malloc((size_t)capacity*sizeof(Aircraft));
    if (!aircrafts){ perror("malloc"); return 1; }

    if (load_csv(args.data_file, &aircrafts, &count, &capacity) != 0){
        fprintf(stderr,"Failed to load %s\n", args.data_file);
    }
    printf("Loaded %d records\n", count);
    if (count==0){ free(aircrafts); return 0; }

    if      (args.phase==1) phase1(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);
    else if (args.phase==2) phase2(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);
    else                    phase3(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);

    free(aircrafts);
    return 0;
}

