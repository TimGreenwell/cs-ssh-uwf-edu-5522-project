/***********************************************************************
 * Parallel Sorting of Aircraft Locations by Distance (Serial version)
 *   - No OpenMP, no MPI â€” for examination/debugging.
 *
 * CLI:
 *   --phase {1|2|3} or --phase=#
 *   [--output file.csv]
 *   files... [lat lon X]
 ***********************************************************************/

#define _POSIX_C_SOURCE 200809L
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <strings.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ---------- constants ----------
#define EARTH_RADIUS_KM 6371.0
#define MAX_LINE 2048
#define DEFAULT_LAT 30.4733
#define DEFAULT_LON -87.1866
#define DEFAULT_X   25
#define EPSILON     0.05
#define INIT_CAPACITY 2000000

// ---------- types ----------
typedef struct {
    char time[32];
    char icao24[16];
    double lat, lon;
    double velocity;
    double heading;
    double baroaltitude;
    char callsign[16];
    double metric;   // phase-dependent metric
    double dist_km;  // final computed distance
} Aircraft;

typedef struct {
    int   phase;         // 1,2,3
    char *output;        // optional CSV file
    double ref_lat;      // optional override
    double ref_lon;
    int    topX;         // optional override
    int    nfiles;
    char **files;
} Args;

// ---------- globals ----------
static const char *DATA_FILE = "input-data.csv";
static char *log_file = (char*)"timings.csv";

// ---------- timing ----------
static double wall_time(void){
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec + ts.tv_nsec * 1e-9;
}

static inline void rstrip_newline(char *s){
    if (!s) return;
    size_t n = strlen(s);
    while (n && (s[n-1]=='\n' || s[n-1]=='\r')) s[--n] = '\0';
}

static int split_csv_simple(char *line, char *fields[], int max_fields){
    /* Split in-place on commas, preserving empty fields. No quotes support. */
    int n = 0;
    char *p = line, *start = line;
    while (*p && n < max_fields){
        if (*p == ','){
            *p = '\0';
            fields[n++] = start;
            start = p + 1;
        }
        p++;
    }
    if (n < max_fields) fields[n++] = start;  // last field
    return n;
}

static inline void rtrim_spaces(char *s){
    if (!s) return;
    size_t n = strlen(s);
    while (n && isspace((unsigned char)s[n-1])) s[--n] = '\0';
}

static inline double parse_double_or0(const char *s){
    if (!s || !*s) return 0.0;
    char *end=NULL;
    double v = strtod(s, &end);
    return (end && *end=='\0') ? v : 0.0;
}

static inline const char* dash_if_empty(const char *s){
	    return (s && *s) ? s : "-";
}
// ---------- math helpers ----------
static inline double deg2rad(double deg){ return deg * M_PI / 180.0; }
static inline double lon_diff(double lon1, double lon2){
    double dlon = lon1 - lon2;
    while (dlon > 180.0) dlon -= 360.0;
    while (dlon < -180.0) dlon += 360.0;
    return dlon;
}
static double full_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat=deg2rad(lat2-lat1), dlon=deg2rad(lon_diff(lon2,lon1));
    double rlat1=deg2rad(lat1), rlat2=deg2rad(lat2);
    double a=pow(sin(dlat/2.0),2.0)+cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
    return 2.0*EARTH_RADIUS_KM*asin(sqrt(a));
}
static double half_haversine(double lat1,double lon1,double lat2,double lon2){
    double dlat=deg2rad(lat2-lat1), dlon=deg2rad(lon_diff(lon2,lon1));
    double rlat1=deg2rad(lat1), rlat2=deg2rad(lat2);
    return pow(sin(dlat/2.0),2.0)+cos(rlat1)*cos(rlat2)*pow(sin(dlon/2.0),2.0);
}
static double distance_from_half(double a){
    if(a<0)a=0; 
    if(a>1)a=1;
    return 2.0*EARTH_RADIUS_KM*asin(sqrt(a));
}
static double equirectangular(double lat1,double lon1,double lat2,double lon2){
    double dlon=lon_diff(lon2,lon1);
    double x=deg2rad(dlon)*cos(deg2rad((lat1+lat2)/2.0));
    double y=deg2rad(lat2-lat1);
    return EARTH_RADIUS_KM*sqrt(x*x+y*y);
}

// ---------- sorting ----------
static int cmp_metric(const void *p1,const void *p2){
    double diff=((const Aircraft*)p1)->metric-((const Aircraft*)p2)->metric;
    return (diff<0)?-1:(diff>0);
}
static int cmp_dist(const void *p1,const void *p2){
    double diff=((const Aircraft*)p1)->dist_km-((const Aircraft*)p2)->dist_km;
    return (diff<0)?-1:(diff>0);
}
static void merge(Aircraft arr[],Aircraft scratch[],int l,int m,int r){
    int i=l,j=m+1,k=l;
    while(i<=m&&j<=r){
        if(arr[i].metric<=arr[j].metric) scratch[k++]=arr[i++];
        else scratch[k++]=arr[j++];
    }
    while(i<=m) scratch[k++]=arr[i++];
    while(j<=r) scratch[k++]=arr[j++];
    for(i=l;i<=r;i++) arr[i]=scratch[i];
}
static void merge_sort(Aircraft arr[],Aircraft scratch[],int l,int r){
    if(l<r){
        int m=(l+r)/2;
        merge_sort(arr,scratch,l,m);
        merge_sort(arr,scratch,m+1,r);
        merge(arr,scratch,l,m,r);
    }
}

// ---------- csv loader ----------
static int load_csv(const char *filename,Aircraft **arr,int *count,int *capacity){
    FILE *fp=fopen(filename,"r");
    if(!fp){ perror("CSV open"); return -1; }

    char line[MAX_LINE];
    int line_num=0;

    /* Header: build a column index map for required fields */
    int idx_time=-1, idx_icao=-1, idx_lat=-1, idx_lon=-1,
        idx_vel=-1, idx_head=-1, idx_callsign=-1, idx_baro=-1;

    if (!fgets(line, MAX_LINE, fp)){ fclose(fp); return 0; }
    rstrip_newline(line);
    line_num++;

    {
        char *fields[64];
        int nf = split_csv_simple(line, fields, 64);
        for (int i=0;i<nf;i++){
            /* compare lowercase keys; header looks lowercase already */
            if (!strcmp(fields[i],"time"))          idx_time = i;
            else if (!strcmp(fields[i],"icao24"))   idx_icao = i;
            else if (!strcmp(fields[i],"lat"))      idx_lat  = i;
            else if (!strcmp(fields[i],"lon"))      idx_lon  = i;
            else if (!strcmp(fields[i],"velocity")) idx_vel  = i;
            else if (!strcmp(fields[i],"heading"))  idx_head = i;
            else if (!strcmp(fields[i],"callsign")) idx_callsign = i;
            else if (!strcmp(fields[i],"baroaltitude")) idx_baro = i;
        }

        /* Fallback for legacy 8-col input (positional) if header not descriptive */
        if (idx_time<0 && nf>=8){
            idx_time=0; idx_icao=1; idx_lat=2; idx_lon=3;
            idx_vel=4; idx_head=5; idx_callsign=6; idx_baro=7;
        }
    }

    while(fgets(line,MAX_LINE,fp)){
        rstrip_newline(line);

        if(*count>=*capacity){
            int newcap = (*capacity)*2;
            Aircraft *tmp = (Aircraft*)realloc(*arr, newcap*sizeof(Aircraft));
            if(!tmp){ perror("realloc"); fclose(fp); return -1; }
            *arr = tmp;
            *capacity = newcap;
        }

        char *fields[64];
        int nf = split_csv_simple(line, fields, 64);

        Aircraft ac; memset(&ac,0,sizeof(ac));

        if (idx_time>=0 && idx_time<nf){ strncpy(ac.time, fields[idx_time], 31); ac.time[31]='\0'; rtrim_spaces(ac.time); }
        if (idx_icao>=0 && idx_icao<nf){ strncpy(ac.icao24, fields[idx_icao], 15); ac.icao24[15]='\0'; rtrim_spaces(ac.icao24); }
        if (idx_callsign>=0 && idx_callsign<nf){ strncpy(ac.callsign, fields[idx_callsign], 15); ac.callsign[15]='\0'; rtrim_spaces(ac.callsign); }

        if (idx_lat>=0 && idx_lat<nf)   ac.lat = parse_double_or0(fields[idx_lat]);
        if (idx_lon>=0 && idx_lon<nf)   ac.lon = parse_double_or0(fields[idx_lon]);
        if (idx_vel>=0 && idx_vel<nf)   ac.velocity = parse_double_or0(fields[idx_vel]);
        if (idx_head>=0 && idx_head<nf) ac.heading  = parse_double_or0(fields[idx_head]);
        if (idx_baro>=0 && idx_baro<nf) ac.baroaltitude = parse_double_or0(fields[idx_baro]);

        (*arr)[(*count)++] = ac;
    }

    fclose(fp);
    return 0;
}

// ---------- output ----------

static void print_top(Aircraft arr[],int N,int X,int phase,
                      double ref_lat,double ref_lon,const char *label){
    if (N<=0 || X<=0) { printf("\n--- %s ---\n(no results)\n", label); return; }
    if (X>N) X=N;

    // Convert first X to display distances
    for(int i=0;i<X;i++){
        if(phase==1) arr[i].dist_km=arr[i].metric;
        else if(phase==2) arr[i].dist_km=distance_from_half(arr[i].metric);
        else arr[i].dist_km=full_haversine(ref_lat,ref_lon,arr[i].lat,arr[i].lon);
    }

    // Pretty, column-aligned table
    printf("\n--- %s ---\n", label);
    printf("  %-4s %-8s %-10s %11s %12s %10s %8s\n",
           "Rank","ICAO","Callsign","Lat(deg)","Lon(deg)","Dist(km)","Alt");
    printf("  %-4s %-8s %-10s %11s %12s %10s %8s\n",
           "----","--------","----------","-----------","------------","----------","--------");

    for(int i=0;i<X;i++){
        printf("  %4d %-8s %-10s %11.4f %12.4f %10.2f %8.0f\n",
               i+1,
               dash_if_empty(arr[i].icao24),
               dash_if_empty(arr[i].callsign),
               arr[i].lat, arr[i].lon,
               arr[i].dist_km, arr[i].baroaltitude);
    }
}


static void write_csv(const char *filename,Aircraft arr[],int X,int phase,
                      double ref_lat,double ref_lon){
    if (X<=0) { printf("No rows to write.\n"); return; }
    FILE *fp=fopen(filename,"w");
    if(!fp){ perror("CSV write"); return; }
    fprintf(fp,"rank,time,icao24,callsign,lat,lon,baroaltitude,dist_km\n");
    for(int i=0;i<X;i++){
        double dist=(phase==1)?arr[i].metric:
                    (phase==2)?distance_from_half(arr[i].metric):
                               full_haversine(ref_lat,ref_lon,arr[i].lat,arr[i].lon);
        fprintf(fp,"%d,%s,%s,%s,%.6f,%.6f,%.1f,%.3f\n",
                i+1,arr[i].time,arr[i].icao24,arr[i].callsign,
                arr[i].lat,arr[i].lon,arr[i].baroaltitude,dist);
    }
    fclose(fp);
    printf("Results written to %s\n",filename);
}
static void log_timing(const char *filename,const char *phase_name,
                       int count,int cores,double runtime){
    (void)cores; // serial
    FILE *fp=fopen(filename,"a");
    if(!fp){ perror("Timing log"); return; }
    fprintf(fp,"%s,%d,%d,%.6f\n",phase_name,count,1,runtime);
    fclose(fp);
}

// ---------- phases (serial) ----------
static void phase1(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon){
    double t0=wall_time();
    for(int i=0;i<count;i++){
        aircrafts[i].metric=full_haversine(ref_lat,ref_lon,
                                           aircrafts[i].lat,aircrafts[i].lon);
    }
    double t1=wall_time();
    printf("Phase 1 runtime: %.3f s\n",t1-t0);
    log_timing(log_file,"Phase1_FullHaversine",count,1,t1-t0);

    Aircraft *arr2=(Aircraft*)malloc((size_t)count*sizeof(Aircraft));
    memcpy(arr2,aircrafts, (size_t)count * sizeof(Aircraft));
    Aircraft *scratch=(Aircraft*)malloc((size_t)count*sizeof(Aircraft));
    merge_sort(arr2,scratch,0,count-1);
    free(scratch);

    print_top(arr2,count,X,1,ref_lat,ref_lon,"Phase 1 (Full Haversine, Merge Sort)");
    memcpy(aircrafts, arr2, (size_t)count * sizeof(Aircraft));
    free(arr2);
}
static void phase2(Aircraft *aircrafts,int count,int X,double ref_lat,double ref_lon){
    double t0=wall_time();
    for(int i=0;i<count;i++){
        aircrafts[i].metric=half_haversine(ref_lat,ref_lon,
                                           aircrafts[i].lat,aircrafts[i].lon);
    }
    double t1=wall_time();
    printf("Phase 2 runtime: %.3f s\n",t1-t0);
    log_timing(log_file,"Phase2_HalfHaversine",count,1,t1-t0);

    Aircraft *scratch=(Aircraft*)malloc((size_t)count*sizeof(Aircraft));
    merge_sort(aircrafts,scratch,0,count-1);
    free(scratch);

    print_top(aircrafts,count,X,2,ref_lat,ref_lon,"Phase 2 (Half Haversine, Merge Sort)");
}
static void phase3(Aircraft *arr,int count,int X,double ref_lat,double ref_lon){
    double coslat=cos(deg2rad(ref_lat));
    if(fabs(coslat)<1e-6) coslat=1e-6;
    int use_lon=fabs(ref_lat)<80.0;

    double t0=wall_time();

    // STEP 1: bounding box
    double lat_thresh_deg=(2.0*X)/111.0;
    double lon_thresh_deg=use_lon?(2.0*X)/(111.0*coslat):360.0;
    int survivors=0;
    for(int i=0;i<count;i++){
        double dlat=fabs(arr[i].lat-ref_lat);
        double dlon=fabs(lon_diff(arr[i].lon,ref_lon));
        if(dlat<=lat_thresh_deg && dlon<=lon_thresh_deg){
            arr[survivors++]=arr[i];
        }
    }
    printf("Bounding-box survivors: %d of %d\n",survivors,count);
    if (survivors==0){ puts("No survivors after bounding box."); return; }

    // STEP 2: equirectangular + sort
    for(int i=0;i<survivors;i++){
        arr[i].metric=equirectangular(ref_lat,ref_lon,arr[i].lat,arr[i].lon);
    }
    qsort(arr,survivors,sizeof(Aircraft),cmp_metric);

    if (X>survivors) X=survivors;
    if (X<=0){ puts("X<=0 after pruning."); return; }
    double d_eq_cutoff=arr[X-1].metric;
    double threshold=d_eq_cutoff*(1.0+EPSILON);

    // STEP 3: secondary pruning
    int cand_count=0;
    for(int i=0;i<survivors;i++){
        if(arr[i].metric<=threshold) arr[cand_count++]=arr[i];
    }
    printf("Post-equirectangular survivors: %d\n",cand_count);
    if (cand_count==0){ puts("No candidates after secondary pruning."); return; }

    // STEP 4: refine with full haversine + sort by true distance
    for(int i=0;i<cand_count;i++){
        arr[i].dist_km=full_haversine(ref_lat,ref_lon,arr[i].lat,arr[i].lon);
    }
    qsort(arr,cand_count,sizeof(Aircraft),cmp_dist);

    double t1=wall_time();
    printf("Phase 3 runtime: %.3f s\n",t1-t0);
    log_timing(log_file,"Phase3_PruneRefine",count,1,t1-t0);

    print_top(arr,cand_count,X,3,ref_lat,ref_lon,"Phase 3 (Adaptive Pruning)");
}

// ---------- args ----------
static int starts_with(const char *s, const char *p){ return strncmp(s,p,strlen(p))==0; }

static Args parse_args(int argc, char *argv[]){
    Args a; memset(&a,0,sizeof(a));
    a.phase   = 0;
    a.output  = NULL;
    a.ref_lat = DEFAULT_LAT;
    a.ref_lon = DEFAULT_LON;
    a.topX    = DEFAULT_X;

    for (int i=1; i<argc; ++i){
        if (starts_with(argv[i],"--phase=")){
            a.phase = atoi(argv[i]+8);
        } else if (!strcmp(argv[i],"--phase") && i+1<argc){
            a.phase = atoi(argv[++i]);
        } else if (starts_with(argv[i],"--output=")){
            a.output = argv[i]+9;
        } else if (!strcmp(argv[i],"--output") && i+1<argc){
            a.output = argv[++i];
        }
    }

    // Check for trailing [lat lon X]
    if (argc>=4){
        char *e1=NULL,*e2=NULL,*e3=NULL;
        double tlat = strtod(argv[argc-3], &e1);
        double tlon = strtod(argv[argc-2], &e2);
        long   tX   = strtol(argv[argc-1], &e3, 10);
        if (e1 && *e1=='\0' && e2 && *e2=='\0' && e3 && *e3=='\0'){
            a.ref_lat = tlat;
            a.ref_lon = tlon;
            a.topX    = (int)tX;
            argc -= 3; // ignore them in file scan
        }
    }

    // collect files
    a.files = (char**)malloc((size_t)argc * sizeof(char*));
    for (int i=1; i<argc; ++i){
        if (starts_with(argv[i],"--")) continue;
	if (a.output && argv[i] == a.output) continue;  // don't treat output file as input
        if (strstr(argv[i],".csv")) a.files[a.nfiles++] = argv[i];
    }
    return a;
}

// ---------- main ----------
int main(int argc,char *argv[]){
    Args args = parse_args(argc, argv);

    if (args.phase < 1 || args.phase > 3 || args.nfiles==0){
        fprintf(stderr,
            "Usage: %s --phase {1|2|3} [--output file.csv] files... [lat lon X]\n", argv[0]);
        fprintf(stderr, "Example: %s --phase=3 --output top.csv data*.csv 30.4733 -87.1866 25\n", argv[0]);
        return 1;
    }


    const char *auto_name =
        (args.phase==1) ? "phase1-output.csv" :
        (args.phase==2) ? "phase2-output.csv" :
                          "phase3-output.csv";

    printf("Phase: %d\n", args.phase);
    printf("Output: %s\n", auto_name);
    printf("Ref: (%.4f, %.4f), TopX=%d\n", args.ref_lat, args.ref_lon, args.topX);
    printf("Files: %d\n", args.nfiles);

    // load
    int capacity = INIT_CAPACITY;
    int count = 0;
    Aircraft *aircrafts = (Aircraft*)malloc((size_t)capacity*sizeof(Aircraft));
    if (!aircrafts){ perror("malloc"); return 1; }

    for (int i=0; i<args.nfiles; ++i){
        if (load_csv(args.files[i], &aircrafts, &count, &capacity) != 0){
            fprintf(stderr,"Failed to load %s\n", args.files[i]);
        }
    }
    printf("Loaded %d records\n", count);
    if (count==0){ free(aircrafts); return 0; }

    // run phase
    if      (args.phase==1) phase1(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);
    else if (args.phase==2) phase2(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);
    else                    phase3(aircrafts,count,args.topX,args.ref_lat,args.ref_lon);

    {
        int X = (args.topX < count ? args.topX : count);
        for (int i = 0; i < X; ++i){
             aircrafts[i].dist_km = (args.phase==1) ? aircrafts[i].metric
                                  : (args.phase==2) ? distance_from_half(aircrafts[i].metric)
                                                    : full_haversine(args.ref_lat, args.ref_lon,
                                                                     aircrafts[i].lat, aircrafts[i].lon);
    }
    write_csv(auto_name, aircrafts, X, args.phase, args.ref_lat, args.ref_lon);
  }

  free(aircrafts);
  free(args.files);
  return 0;
}

